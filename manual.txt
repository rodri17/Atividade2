CURL TESTING ---------------------------------------------------------------------------------------

Erros esperados:

DELETE:
curl -X DELETE "http://localhost:8000?key=inexistente"
# Resposta esperada: {"erro":"Palavra não encontrada"} (HTTP 404)

GET:
curl -X GET "http://localhost:8000?key=inexistente"
# Resposta esperada: {"erro":"Palavra não encontrada"} (HTTP 404)


Fluxo de Execução Normal:

curl -X PUT http://localhost:8000/ -H "Content-Type: application/json" -d "{\"data\": {\"key\": \"exemplo\", \"value\": \"Definicao de teste\"}}"
# Resposta esperada: {"status":"sucesso"} (HTTP 200)

curl http://localhost:8000/?key=exemplo
# Resposta esperada: {"data":{"value":"Definicao de teste"}} (HTTP 404)

curl -X DELETE http://localhost:8000/?key=exemplo
# Resposta esperada: {"status":"sucesso"} (HTTP 200)


HEALTHCHECKS ---------------------------------------------------------------------------------------


# Verificar status de todos os serviços no Docker
docker ps --format "{{.Names}}: {{.Status}}"

# Frontend
curl http://localhost:3000/health
# Resposta esperada: {"status":"ok"}

# Redis Cluster (para cada nó)
docker exec -it atividade2-redis-node1-1 redis-cli ping
docker exec -it atividade2-redis-node2-1 redis-cli ping

# RabbitMQ Cluster (cada nó)
docker exec -it atividade2-rabbitmq1-1 rabbitmq-diagnostics check_running
docker exec -it atividade2-rabbitmq1-1 rabbitmqctl cluster_status

# PHP-API
curl -f http://localhost:8000/health
# Resposta esperada: {"status":"ok"}

# Nginx
curl -i http://localhost:8000/nginx-health
# Resposta esperada: Nginx Ok (HTTP/1.1 200 OK)

# CockroachDB (cada nó)
curl -X GET -I http://localhost:8080/health?ready=1
curl -X GET -I http://localhost:8081/health?ready=1
curl -X GET -I http://localhost:8082/health?ready=1
# Resposta esperada: { } 



Comandos úteis para depuração do sistema ------------------------------------------------------------------------------------------------------------


Construir containers:
docker-compose down
docker-compose build --no-cache
docker-compose up -d

Configurar Redis Cluster:
docker exec -it atividade2-redis-node1-1 redis-cli --cluster create ^
redis-node1:6379 ^
redis-node2:6379 ^
redis-node3:6379 ^
redis-node4:6379 ^
redis-node5:6379 ^
redis-node6:6379 ^
--cluster-replicas 1 --cluster-yes

Verificar o cluster:
docker exec -it atividade2-redis-node1-1 redis-cli cluster nodes

Verficiar logs do backend:
docker logs atividade2-backend-1

Verificar saúde do container:
docker exec -it atividade2-redis-node1-1 redis-cli --cluster check atividade2-redis-node1-1:6379

Verificar cluster state:
docker exec -it atividade2-redis-node1-1 redis-cli

Verificar conectividade do cluster:
docker exec -it atividade2-api-1 sh
# python -c "from rediscluster import RedisCluster; rc = RedisCluster(startup_nodes=[{'host':'redis-node1','port':6379}], decode_responses=True); print(rc.ping())"
{'172.18.0.6:6379': True, '172.18.0.5:6379': True, '172.18.0.4:6379': True, '172.18.0.3:6379': True, '172.18.0.2:6379': True, '172.18.0.7:6379': True}
#

Inspecionar a network:
docker network inspect atividade2_app-network

Verificar resolução de nomes:
docker exec atividade2-nginx-proxy-1 cat /etc/resolv.conf

Verificação detalhada das bases de dados:
docker exec -it atividade2-cockroachdb1-1 cockroach node status --insecure

Aceder base de dados dentro do container e verificar conteudos da tabela:
docker exec -it atividade2-cockroachdb2-1 cockroach sql --insecure --host=cockroachdb2 --database=distribuido_db --execute="SELECT * FROM dictionary;"

Testar redis cache:
docker exec -it atividade2-redis-node1-1 redis-cli GET "exemplo"

Executar script no Docker ou WSL:
chmod +x start.sh
./start.sh

Executar testes de carga:
docker-compose run k6 run /testes-carga/scripts/load-test.js
docker-compose run k6 run /testes-carga/scripts/smoke-test.js
docker-compose run k6 run /testes-carga/scripts/stress-test.js
docker-compose run k6 run /testes-carga/scripts/soak-test.js


Comando	Finalidade:
docker-compose up -d	                                            Inicia os containers em segundo plano.
docker-compose logs -f	                                            Visualiza logs em tempo real (útil para depuração).
docker-compose down	                                                Para e remove containers, redes e volumes.
docker-compose build	                                            Reconstrói imagens após alterações em Dockerfiles.
docker exec -it <container_id> bash	                                Acessa o terminal de um container em execução.
docker-compose restart <service>	                                Reinicia um serviço específico (ex: backend).
docker exec -it atividade2-redis-node1-1 redis-cli --cluster nodes	Lista todos os nós e seus papéis.
docker exec -it atividade2-redis-node1-1 redis-cli GET <key>	    Verifica um dado em um nó específico.
docker-compose logs -f redis-node1	                                Monitora logs de um nó.
docker volume prune                                                 Elimina todos os volumes
docker image prune -a                                               Elimina todas as imagens
docker system prune -a --volumes                                    Elimina volumes e imagens

